= Workflows
:toc: macro
:toc-title: Contents

:link-docs-workflow-syntax: https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions
:link-example-workflows: https://github.com/actions/starter-workflows

toc::[]

== Overview

A GitHub workflow is a process that you set up in your repository to automate
software development life cycle tasks.

Workflows are scoped to repositories and are configured in YAML files in the
`./.github/workflows` directory of the repository. A repository may have
multiple workflows; each will be configured via a single YAML file.

The {link-docs-workflow-syntax}[workflow syntax is documented here], and GitHub
also has a {link-example-workflows}[repo of example workflows] you can use to
get started.

Workflows are triggered by link:./events.adoc[*events*]. The events that trigger
the execution of a workflow are configured via the `on` attribute in the
workflow's YAML config, eg. `on: push`.

Each workflow is composed of one or more link:./jobs.adoc[*jobs*]. Every workflow
MUST have at least one job. Each job is associated with a
link:./runners.adoc[*runner*], which is a runtime environment for execution of the
job. A runner may be GitHub-hosted or self-hosted, and the actual infrastructure
may be a container or a virtual machine (or even a physical machine in the case
of self-hosted runners).

A *run* is an instance of a workflow execution. Each run is triggered by a single
event. It a workflow can be triggered by multiple events, each event will trigger
a separate run by default.

Each job has link:./steps.adoc[*steps*] to complete. Each step may be a shell
command or a reference to an link:./actions.adoc[*action*]. An action can be
thought of as a plugin to a workflow. It is a packaged bundle of reusable
functionality. Many open source actions are shared via the GitHub Marketplace,
making it easier to compose custom workflows from existing actions.

== Expressions

Expressions can be used within workflow files to dynamically evaluate and
manipulate data at runtime, so creating more flexible and intelligent automation.
Expressions are used in various workflow scenarios, such as conditional
statements, setting variables, or generating dynamic content and output.

Expressions are written using the `${{ <expression> }}` syntax.

Expressions can be composed from a combination of:

* Literal values: string, numbers, booleans, null.
* link:./contexts.adoc[Contexts]: values passed via the many workflow contexts.
* link:./functions.adoc[Functions]: built-in functions provided by GitHub Action runners.

Expressions also support operators such as `!`, `<`, `>`, `&&`, `||`, `==`, `!=`,
and many others.

Expressions are perhaps most commonly used to set conditions, in which we use
them to inject values directly into shell conditions, like this:

[source,yaml]
----
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Conditional step using an expression
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "This is a push to the main branch."
          fi
----

We can also use expressions in `if` statements when deciding whether to execute
a step or a job. Under the `if` key, we don't normally need to use the special
`${{ <expression> }}` syntax, because the value of `if` is always evaluated as
an expression.

[source,yaml]
----
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Conditional step using an expression
        if: github.event_name == "push" && github.ref == "refs/heads/main"
        run: echo "This is a push to the main branch."
----

[NOTE]
======
`if` expressions that start with `!` _do_ need to be enclosed in the
`${{ <expression> }}` syntax, because the `!` character is a special character
in YAML.
======

Expressions are most commonly used to reference information from various sources
within the workflow, such as the repository, the runner, or the workflow itself.
This information is made available via workflow contexts â€“ basically, APIs that
are made available by the runner.

.Example: dynamic variable assignment
[source,yaml]
----
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Set variable using an expression
        run: |
          # Define a dynamic variable using an expression
          MY_VAR="Hello, ${{ github.actor }}!"

          # Use the variable in an echo statement
          echo $MY_VAR
----

